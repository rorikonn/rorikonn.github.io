<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>GAS系统-预测 • Hexo</title><meta name="description" content="GAS系统-预测 - John Doe"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Hexo"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="Hexo">Hexo</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">GAS系统-预测</h1><div class="post-info"><a></a>2025-08-01</div><div class="post-content"><p>GAS的客户端预测系统。<strong>预测</strong>即在网络游戏中，客户端先自行相应输入等事件，以获得更及时的操作反馈，预测系统需要的处理的问题包括：</p>
<ol>
<li><p>预测失败后预测改动的回滚。</p>
</li>
<li><p>预测成功时，不会重复应用服务器下发的已经预测过的改动。</p>
</li>
<li><p>预测链的处理，即一个预测的内容引发了其他更多的预测。</p>
</li>
<li><p>预测的完整性，保证所有需要预测内容都正确的被预测了。</p>
</li>
<li><p>预测的修改覆盖由服务器同步的状态。</p>
</li>
</ol>
<hr>
<h3 id="1-GAS预测系统概述"><a href="#1-GAS预测系统概述" class="headerlink" title="1. GAS预测系统概述"></a><strong>1. GAS预测系统概述</strong></h3><p>GAS的预测系统 对业务逻辑透明，在Ability执行的时候，会自动预测其中能预测的部分，并处理好预测相关的逻辑。也正因此，只有部分内容支持预测。</p>
<ul>
<li><p>激活GA，包括链式激活，即一个预测的GA触发另外一个GA。</p>
</li>
<li><p>应用GE，只支持其中的 Attribute Modification 和 Gameplay Tag Modification，不支持 Attribute Executions，GE的移除和周期性效果也不支持预测。</p>
</li>
<li><p>蒙太奇。</p>
</li>
<li><p>位移，集成在移动组件中。</p>
</li>
</ul>
<hr>
<h3 id="2-GAS预测系统实现"><a href="#2-GAS预测系统实现" class="headerlink" title="2. GAS预测系统实现"></a><strong>2. GAS预测系统实现</strong></h3><p>预测系统的一个基础概念是 <strong>预测键（Prediction Key）</strong>，预测键本质是一个由客户端生成的唯一ID。客户端会将预测键发送给服务器，并将其预测的行为和预测产生的影响关联到这个预测键上。服务器可以回复给客户端<strong>接受 &#x2F; 拒绝</strong>这个预测键，并且将服务器产生的影响也关联到这个预测键上。</p>
<p><strong>注意</strong>：预测键总是可以从客户端发送到服务器，但是从服务器发送到客户端时，只会发给将这个预测键的发送方（将这个预测键发送给服务器的那个客户端），其他的客户端只会收到一个非法的预测键。相关逻辑在 <code>FPredictionKey::NetSerialize</code> 中实现。</p>
<hr>
<h4 id="GA的预测逻辑"><a href="#GA的预测逻辑" class="headerlink" title="- GA的预测逻辑"></a>- <strong>GA的预测逻辑</strong></h4><p>激活GA是首要的预测行为——它会生成最初的预测键。当客户端以预测的方式激活某个GA时，总是会显示的请求服务器，并且服务器会显示的回复。当一个GA被以预测的方式激活后（在服务器回复还没有发送之前），客户端存在”预测窗口“，在这个窗口期间，客户端可以自行预测GA产生的影响而不用询问服务器。预测窗口在调用 <code>ActivateAbility</code> 之后生效，在 <code>ActivateAbility</code> 的调用结束后失效。所以我们不能预测多帧的行为，在蓝图中的 <code>Timer</code> 或者 <code>Ability Task</code> 都会使预测窗口失效。</p>
<p><code>AbilitySystemComponent</code> 使用一系列方法在客户端与服务器之间通信GA的激活：<code>TryActivateAbility</code> -&gt; <code>ServerTryActivateAbility</code> -&gt; <code>ClientActivateAbility(failed/succeed)</code>。</p>
<ol>
<li><p>客户端调用 <code>TryActivateAbility</code>，它生成一个预测键，并且调用<code>ServerTryActivateAbility</code>。</p>
</li>
<li><p>客户端逻辑继续执行，将生成的预测键保存在 Ability 的 <code>ActivationInfo</code> 中并调用<code>ActivateAbility</code>。</p>
</li>
<li><p>在 <code>ActivateAbility</code> 的调用结束之前，所有产生的影响都需要与预测键关联。</p>
</li>
<li><p>服务器在 <code>ServerTryActivateAbility</code> 中决定GA是否执行成功，调用 <code>ClientActivateAbility(failed/succeed)</code> 并且将客户端发过来的预测键保存在 <code>UAbilitySystemComponent::ReplicatedPredictionKey</code>中。</p>
</li>
<li><p>如果客户端收到了<code>ClientAbilityFailed</code>，则会立刻结束GA，并且回滚预测键关联的所有改动。</p>
<ol>
<li><p>回滚通过 <code>FPredictionKeyDelegates</code> 和 <code>FPredictionKey::NewRejectedDelegate/NewCaughtUpDelegate/NewRejectOrCaughtUpDelegate</code> 注册回调来完成。</p>
</li>
<li><p><code>ClientAbilityFailed</code> 是唯一拒绝预测键的地方，所以我们的当前所有的预测都依赖于GA是否激活。</p>
</li>
</ol>
</li>
<li><p>如果服务器GA执行成功，客户端需要等待属性同步将预测键的成功信息同步下来（执行成功的RPC会立即下发，但是属性同步可能会延迟）。一旦 <code>ReplicatedPredictionKey</code> 同步完成，客户端就可以回滚所有相关的预测改动了。 </p>
<ul>
<li>在 <code>FReplicatedPredictionKeyItem::OnRep</code> 中查看预测键的确认逻辑。</li>
<li>在 <code>UAbilitySystemComponent::ReplicatedPredictionKeyMap</code> 中查看预测键实际是如何同步的。</li>
<li>在 <code>~FScopedPredictionWindow</code> 中查看服务器是如果确认预测键的。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="GE的预测逻辑"><a href="#GE的预测逻辑" class="headerlink" title="- GE的预测逻辑"></a>- <strong>GE的预测逻辑</strong></h4><p>GE跟随GA被一起预测，不会单独的确认或拒绝</p>
<ol>
<li><p>GE只有在客户端有合法的预测键时才会被应用。</p>
</li>
<li><p>如果GE被预测了，那么其相关的属性、GameplayCue、GameplayTag都会被一起预测。</p>
</li>
<li><p>当一个 <code>FActiveGameplayEffect</code> 被创建的时候，会将预测键保存在里面 <code>FActiveGameplayEffect::PredictionKey</code>。</p>
</li>
<li><p>服务器也会将预测键放到其创建的 <code>FActiveGameplayEffect</code> 中，并一起同步下来。</p>
</li>
<li><p>当客户端收到包含合法的预测键的 <code>FActiveGameplayEffect</code> 时，会检查是否有相同预测键的对象存在，如果有则不会再次应用这个效果。这解决了预测的效果重复的问题。</p>
</li>
<li><p>同时，<code>FReplicatedPredictionKeyItem::OnRep</code> 确认预测键时，被预测的效果会被移除，同时也会再次检查预测键来决定是否需要执行其移除逻辑。</p>
</li>
</ol>
<p><code>FActiveGameplayEffectsContainer::ApplyGameplayEffectSpec</code> 注册了预测键被确认时的逻辑。</p>
<p>在<code>FActiveGameplayEffect::PostReplicatedAdd</code>，<code>FActiveGameplayEffect::PreReplicatedRemove</code> 和 <code>FActiveGameplayCue::PostReplicatedAdd</code>中查看预测键是怎么与GE、GC关联上的。</p>
<hr>
<h4 id="属性预测逻辑"><a href="#属性预测逻辑" class="headerlink" title="- 属性预测逻辑"></a>- <strong>属性预测逻辑</strong></h4><p>为了解决属性预测和属性同步互相覆盖的问题，我们<strong>预测改动而不是预测绝对值</strong>。并且把瞬时的修改当作永久持续性的修改，来解决回滚的问题。</p>
<p>同时我们把服务器同步的值当作”基础值“而不是”最终值“，并且在同步完成后，重新计算”最终值“。</p>
<ol>
<li><p>在预测时，将瞬时修改当作永久持续性的修改来处理。见 <code>UAbilitySystemComponent::ApplyGameplayEffectSpecToSelf</code>。</p>
</li>
<li><p>在属性同步下来时，<strong>总是</strong>调用 <code>RepNotify</code> 函数（而不是仅在值发生改变时调用，因为预测会提前改变属性）。使用<code>REPNOTIFY_Always</code>完成。</p>
</li>
<li><p>在 <code>RepNofity</code> 函数中，调用 <code>AbilitySystemComponent::ActiveGameplayEffects</code> 来基于新的”基础值“更新”最终值“。使用 <code>GAMEPLAYATTRIBUTE_REPNOTIFY</code> 宏完成。</p>
</li>
<li><p>其他的逻辑与GE同步类似：当预测键被确认时，预测的GE会被移除并回归到服务器下发的状态。</p>
</li>
</ol>
<hr>
<h4 id="GC的预测逻辑"><a href="#GC的预测逻辑" class="headerlink" title="- GC的预测逻辑"></a>- <strong>GC的预测逻辑</strong></h4><p>GE中触发的GC已经包含在GE的预测逻辑中了。除此之外，GC也能单独使用，相关函数（<code>UAbilitySystemComponent::ExecuteGameplayCue</code> 等）也考虑了预测逻辑。</p>
<ol>
<li><p>在 <code>UAbilitySystemComponent::ExecuteGameplayCue</code> 函数中，如果是Authority的会直接广播，否则如果有合法的预测键，则会进行预测。</p>
</li>
<li><p>在收到GC广播时，如果包含了合法的预测键，则不会执行，假设客户端之前已经预测过了。</p>
</li>
</ol>
<hr>
<h4 id="Triggered-Data预测逻辑"><a href="#Triggered-Data预测逻辑" class="headerlink" title="- Triggered Data预测逻辑"></a>- <strong>Triggered Data预测逻辑</strong></h4><p>Triggered Data 用于触发GA。其核心逻辑与 <code>ActivateAbility</code> 代码路径一致，区别在于GA并非由玩家输入触发，而是其他游戏逻辑事件驱动。客户端可以预测这些事件从而预测GA。</p>
<p>但是存在以下细节：</p>
<ul>
<li><p>服务器不会等客户端通知，而是会同步的执行事件触发。服务器会维护一个通过预测触发过的GA列表。当收到触发的GA的 <code>TryActivate</code> 时，会检查是否已经有一个正在运行了，并返回相关信息。</p>
</li>
<li><p>回滚逻辑还没有处理。</p>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2025/08/01/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Gameplay%20Ability%20System/GAS%E7%B3%BB%E7%BB%9F-%E8%BE%93%E5%85%A5/">prev</a><a class="next" href="/2025/08/01/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Gameplay%20Ability%20System/GAS%E7%B3%BB%E7%BB%9F/">next</a></div><div class="copyright"><p>&copy; 2025 <a href="https://github.com/rorikonn">Jimmy Zou</a><br>Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a></p></div></footer></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>